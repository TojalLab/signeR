################################################################################
# Parallel version of Gibbs Sampler
#
# Parameters:
# M: matrix of mutation counts, each column corresponds to one sample 
# W: matrix of mutation opportunities, each column corresponds to one sample
# Z: start values for this tensor
# P,E,Ap,Bp,Ae,Be: start values for these matrices
# ae,be,lp,le,var.ap,var.ae: parameters for the sampler, see signeR parameters.
# burn: number of burning iterations of the Gibbs sampler
# eval: number of final iterations of the Gibbs sampler
# Pfixed: provided P matrix should it be used as a start value
# (FALSE, default) or should it be held fixed along the algorithm (Pfixed=TRUE)
# Zfixed, Thetafixed and Afixed: whether those parameters must be held fixed  
# keep_par: if TRUE, algorithm export hyperparameters
# n_cor: number of cores to be used in cluster for parallel processing 
# sGap: number of generated samples that are skipped when distributing 
#             parallel processing tasks.
# min_samples_c: minimum number of samples generated by each core when 
#                       parallel = TRUE 
################################################################################
GibbsSamplerParallel<-function(M,W,Z,P,E,Ap,Bp,Ae,Be,ap,bp,ae,be,lp,le,
    var.ap,var.ae,burn,eval,
    Pfixed=FALSE,Zfixed=FALSE,Thetafixed=FALSE,
    Afixed=FALSE,keep_par=TRUE,n_cor=NA,
    sGap=10,min_samples_c=200){
    if(is.na(n_cor)){
       totalcores<-detectCores()
       usablecores<-totalcores-1
    }else{
        usablecores<-n_cor
    }
    if( eval/usablecores >= min_samples_c){
        usedcores<-usablecores
        samples_per_core<-ceiling(eval/usablecores)
    }else{
        samples_per_core<-min_samples_c
        usedcores<-ceiling(eval/samples_per_core)
    }
    if(usedcores>1){
        Run0<-GibbsSamplerCpp(M,W,Z,P,E,Ap,Bp,Ae,Be,ap,bp,ae,be,lp,le,
            var.ap,var.ae,burn,eval=usedcores*(sGap+1),
            Pfixed,Zfixed,Thetafixed,Afixed,keep_par=TRUE)
        used_samps <- c(1:usedcores)*(sGap+1)
        Zs <- Run0[[1]][,,,used_samps,drop=FALSE]
        Ps <- Run0[[3]][,,used_samps,drop=FALSE]
        Es <- Run0[[4]][,,used_samps,drop=FALSE]
        Aps <- Run0[[5]][,,used_samps,drop=FALSE]
        Bps <- Run0[[6]][,,used_samps,drop=FALSE]
        Aes <- Run0[[7]][,,used_samps,drop=FALSE]
        Bes <- Run0[[8]][,,used_samps,drop=FALSE]
        cl<-makeCluster(usedcores)
        clusterExport(cl,c("Zs", "Ps", "Es", "Aps", "Bps", "Aes", "Bes", "M", "W",
            "ap", "bp", "ae", "be", "lp", "le", "var.ap", "var.ae",
            "samples_per_core","Pfixed","Zfixed","Thetafixed","Afixed",
            "keep_par","GibbsSamplerCpp"), envir = environment())
        Runs<-parLapply(cl,as.list(1:usedcores),function(c){
            Z0 <- Zs[,,,c]
            dim(Z0)<-dim(Zs)[1:3]
            P0 <- Ps[,,c]
            dim(P0)<-dim(Ps)[1:2]
            E0 <- Es[,,c]
            dim(E0)<-dim(Es)[1:2]
            Ap0 <- Aps[,,c]
            dim(Ap0)<-dim(Aps)[1:2]
            Bp0 <- Bps[,,c]
            dim(Bp0)<-dim(Bps)[1:2]
            Ae0 <- Aes[,,c]
            dim(Ae0)<-dim(Aes)[1:2]
            Be0 <- Bes[,,c]
            dim(Be0)<-dim(Bes)[1:2]
            ThisRun<-GibbsSamplerCpp(M,W,Z0,P0,E0,Ap0,Bp0,Ae0,Be0,ap,bp,ae,be,lp,le,
                var.ap,var.ae,burn=0,eval=samples_per_core,Pfixed,
                Zfixed,Thetafixed,Afixed,keep_par)
            return(ThisRun)
        })
        stopCluster(cl)
        if (Zfixed){
            out<-c(3,4)
        }else if (Thetafixed){
            out<-c(2)
        }else if (Afixed){
            out<-c(3,4)
        }else if (keep_par){
            out<-c(1,3:8)
        }else{
            out<-c(3,4,6,8)
        }
        L<-as.list(rep(NA,8))
        for (k in out){
            L[[k]]<-Runs[[1]][[k]]
            for(r in 2:usedcores){
                L[[k]]<-sampleBind(L[[k]],Runs[[r]][[k]])
                Runs[[r]][[k]]<-NA #saving memory
            }
        }
    }else{
        L<-GibbsSamplerCpp(M,W,Z,P,E,Ap,Bp,Ae,Be,ap,bp,ae,be,lp,le,
            var.ap,var.ae,burn,eval,
            Pfixed,Zfixed,Thetafixed,Afixed,keep_par)
    }
    return(L)
}

sampleBind<-function(A,B){
    da<-dim(A)
    db<-dim(B)
    if(da[1]==db[1] & da[2]==db[2]){
        lastdim<-length(da)
        dr<-da
        dr[lastdim]<-da[lastdim]+db[lastdim]
        R<-array(c(as.vector(A),as.vector(B)),dim=dr)
        names(dim(R))<-names(da)
    }else stop("Error: array dimensions are not equal.\n")
    return(R)
}
